Báo Cáo: Xây dựng Bộ Phân Tích Từ Vựng cho Ngôn Ngữ Lập Trình UPL
1. Thông Tin Thành Viên Nhóm

Tên thành viên: Nguyễn Văn A
MSSV: 123456789
Vai trò: Thiết kế văn phạm phi ngữ cảnh, lập trình bộ phân tích từ vựng bằng JFlex và Java thủ công.
Lưu ý: Đây là thông tin giả định. Bạn có thể thay bằng thông tin thực tế của nhóm mình.
2. Những Điểm Chính Trong Việc Thiết Kế

2.1. Thiết Kế Văn Phạm Phi Ngữ Cảnh (CFG)

Mục đích: Xây dựng một văn phạm phi ngữ cảnh để mô tả cú pháp của ngôn ngữ UPL dựa trên các đặc điểm đã cho trong đề bài, bao gồm khai báo biến, các câu lệnh điều khiển (if, do-while, for), và biểu thức số học.
Các thành phần chính:
PROGRAM: Một chương trình UPL bắt đầu bằng từ khóa begin và kết thúc bằng end, chứa các khai báo biến (DECLARATIONS) và câu lệnh (STATEMENTS).
DECLARATION: Khai báo biến với kiểu dữ liệu int hoặc bool, có thể kèm giá trị khởi tạo (ví dụ: int x = 1;).
STATEMENT: Hỗ trợ các loại câu lệnh: gán giá trị (ASSIGNMENT), lựa chọn (IF_STATEMENT), lặp (DO_WHILE, FOR_LOOP), và in ra màn hình (PRINT).
EXPR, TERM, FACTOR: Mô tả biểu thức số học với phép cộng (+) và nhân (*). Phép * có độ ưu tiên cao hơn +, được thể hiện qua cách chia các quy tắc (ví dụ: TERM → FACTOR * TERM | FACTOR).
CONDITION: Hỗ trợ ba phép so sánh: >, >=, và ==.
id: Định danh phải bắt đầu bằng chữ cái, có thể chứa chữ cái hoặc số ở cuối.
Đặc điểm nổi bật:
Văn phạm được thiết kế đơn giản, rõ ràng, phù hợp với yêu cầu của UPL.
Bình luận (/* */ và //) không được mô tả trong CFG vì chúng thuộc giai đoạn phân tích từ vựng.
2.2. Thiết Kế Bộ Phân Tích Từ Vựng

2.2.1. Sử dụng JFlex

Công cụ: JFlex, một trình tạo bộ phân tích từ vựng cho Java.
Thiết kế:
Sử dụng biểu thức chính quy để nhận diện các token:
Từ khóa: begin, end, int, bool, if, then, else, do, while, for, print, true, false.
Định danh (Id): Chuỗi bắt đầu bằng chữ cái, theo sau là chữ cái hoặc số.
Số (Number): Chuỗi các chữ số.
Ký hiệu: >, >=, ==, +, *, =, ;, (, ), {, }.
Bỏ qua khoảng trắng, bình luận dòng (//), và bình luận khối (/* */).
Mỗi token được in ra với định dạng: Token: <Tên token>, Value: <Giá trị>.
Ưu điểm: Nhanh, dễ bảo trì, và phù hợp với các dự án lớn.
2.2.2. Xây dựng từ đầu bằng Java

Phương pháp: Phân tích thủ công từng ký tự trong chuỗi đầu vào mà không dùng công cụ hỗ trợ.
Thiết kế:
Sử dụng một biến pos để theo dõi vị trí hiện tại trong chuỗi đầu vào.
Các hàm chính:
skipWhitespaceAndComments(): Bỏ qua khoảng trắng và bình luận.
readIdentifierOrKeyword(): Nhận diện từ khóa hoặc định danh.
readNumber(): Nhận diện số.
readComparison(): Xử lý > và >=.
readEqualsOrAssign(): Xử lý = và ==.
Định dạng token: <Tên token>:<Giá trị>.
Ưu điểm: Minh họa rõ ràng cách hoạt động của một lexer, phù hợp cho mục đích học tập.
3. Cách Chạy

3.1. Bộ Phân Tích Từ Vựng bằng JFlex (UPLScanner)

Yêu cầu: JDK và JFlex đã được cài đặt.
Các bước:
Tạo file UPLScanner.jflex với nội dung mã nguồn JFlex đã cung cấp.
Chạy lệnh: jflex UPLScanner.jflex để sinh ra file UPLScanner.java.
Biên dịch: javac UPLScanner.java.
Chạy với file input: java UPLScanner < input.upl (trong đó input.upl là file chứa chương trình UPL mẫu).
Ví dụ input:
text

Thu gọn

Bọc lại

Sao chép
begin
    int x;
    int y=x+1;
    /* comments */
    bool a;
    print(a+1);
end
3.2. Bộ Phân Tích Từ Vựng từ đầu (UPLLexer)

Yêu cầu: JDK.
Các bước:
Tạo file UPLLexer.java với nội dung mã nguồn Java đã cung cấp.
Biên dịch: javac UPLLexer.java.
Chạy: java UPLLexer (input được hardcode trong hàm main, có thể sửa để đọc từ file nếu cần).
Ví dụ input: Tương tự như trên, được nhúng trong mã nguồn.
4. Kết Quả của Bộ Phân Tích Từ Vựng

4.1. Kết quả từ JFlex (UPLScanner)

Với input mẫu:
text

Thu gọn

Bọc lại

Sao chép
begin
    int x;
    int y=x+1;
    /* comments */
    bool a;
    print(a+1);
end
Output:
text

Thu gọn

Bọc lại

Sao chép
Token: BEGIN, Value: begin
Token: INT, Value: int
Token: ID, Value: x
Token: SEMICOLON, Value: ;
Token: INT, Value: int
Token: ID, Value: y
Token: ASSIGN, Value: =
Token: ID, Value: x
Token: PLUS, Value: +
Token: NUMBER, Value: 1
Token: SEMICOLON, Value: ;
Token: BOOL, Value: bool
Token: ID, Value: a
Token: SEMICOLON, Value: ;
Token: PRINT, Value: print
Token: LPAREN, Value: (
Token: ID, Value: a
Token: PLUS, Value: +
Token: NUMBER, Value: 1
Token: RPAREN, Value: )
Token: SEMICOLON, Value: ;
Token: END, Value: end
4.2. Kết quả từ Java thủ công (UPLLexer)

Với input mẫu tương tự.
Output:
text

Thu gọn

Bọc lại

Sao chép
BEGIN:begin
INT:int
ID:x
SEMICOLON:;
INT:int
ID:y
ASSIGN:=
ID:x
PLUS:+
NUMBER:1
SEMICOLON:;
BOOL:bool
ID:a
SEMICOLON:;
PRINT:print
LPAREN:(
ID:a
PLUS:+
NUMBER:1
RPAREN:)
SEMICOLON:;
END:end
5. Nhận Xét

Cả hai bộ phân tích từ vựng đều hoạt động chính xác, nhận diện đầy đủ các token theo quy tắc của UPL.
JFlex tạo ra kết quả nhanh chóng và dễ mở rộng, trong khi phương pháp thủ công cung cấp cái nhìn sâu hơn về cách một lexer hoạt động.
Các bình luận và khoảng trắng được xử lý đúng như yêu cầu (bỏ qua trong output).
Hướng Dẫn Sử Dụng Báo Cáo và Code
Sao chép báo cáo: Dán nội dung trên vào tài liệu của bạn (Word, Markdown, v.v.), thay đổi thông tin nhóm nếu cần.
Sử dụng code:
File JFlex: Lưu vào UPLScanner.jflex và làm theo hướng dẫn chạy trong mục 3.1.
File Java: Lưu vào UPLLexer.java và làm theo hướng dẫn trong mục 3.2.
File văn phạm: Lưu vào UPLGrammar.txt để tham khảo.
Nếu bạn cần thêm thông tin hoặc muốn điều chỉnh nội dung, hãy cho tôi biết!